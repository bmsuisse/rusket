"""Visualization tools and graph algorithms for frequent itemsets."""

from __future__ import annotations

import typing
from typing import Any

import numpy as np
import pandas as pd

if typing.TYPE_CHECKING:
    import networkx  # type: ignore


def to_networkx(
    rules_df: pd.DataFrame,
    source_col: str = "antecedents",
    target_col: str = "consequents",
    edge_attr: str = "lift",
) -> networkx.DiGraph:  # type: ignore
    """Convert a Rusket association rules DataFrame into a NetworkX Directed Graph.

    Nodes represent individual items. Directed edges represent rules
    (antecedent â†’ consequent). Edge weights are set by the ``edge_attr``
    parameter (typically lift or confidence).

    This is extremely useful for running community detection algorithms
    (e.g., Louvain, Girvan-Newman) to automatically discover **product clusters**,
    or for visualising cross-selling patterns as a force-directed graph.

    Parameters
    ----------
    rules_df : pd.DataFrame
        A Pandas DataFrame generated by ``rusket.association_rules()``.
    source_col : str, default='antecedents'
        Column name containing antecedents (graph edge sources).
    target_col : str, default='consequents'
        Column name containing consequents (graph edge targets).
    edge_attr : str, default='lift'
        The metric to use as edge weight/thickness.

    Returns
    -------
    networkx.DiGraph
        A directed graph of the association rules. If ``rules_df`` is empty,
        returns an empty ``DiGraph``.

    Notes
    -----
    Requires the ``networkx`` package (``pip install networkx``).
    When multiple rules produce the same directed edge, only the highest-weight
    rule is retained.

    Examples
    --------
    >>> import rusket
    >>> G = rusket.viz.to_networkx(rules_df, edge_attr="lift")
    >>> # Community detection with networkx
    >>> import networkx.algorithms.community as nx_comm
    >>> communities = nx_comm.greedy_modularity_communities(G.to_undirected())
    """
    try:
        import networkx as nx  # type: ignore
    except ImportError as err:
        raise ImportError(
            "The 'networkx' library is required to use `to_networkx()`. "
            "Install it via `pip install networkx` or `uv add networkx`."
        ) from err

    if rules_df.empty:
        return nx.DiGraph()

    if source_col not in rules_df.columns or target_col not in rules_df.columns:
        raise ValueError(f"Columns {source_col} and {target_col} must exist in the DataFrame.")

    if edge_attr is not None and edge_attr not in rules_df.columns:
        raise ValueError(f"Edge attribute column '{edge_attr}' not found in the DataFrame.")

    G = nx.DiGraph()

    for _, row in rules_df.iterrows():
        # Rules can have multiple items in antecedents/consequents.
        # For a graph, we create edges from every item in antecedent to every item in consequent.
        # Note: If antecedents -> consequents is (A, B) -> (C),
        # we create A->C and B->C with the same rule weight.

        antecedents = list(row[source_col])
        consequents = list(row[target_col])
        weight = row[edge_attr] if edge_attr else 1.0

        for ant in antecedents:
            for con in consequents:
                if G.has_edge(ant, con):
                    # If multiple rules imply the same edge, keep the strongest one
                    if G[ant][con]["weight"] < weight:
                        G[ant][con]["weight"] = weight
                else:
                    G.add_edge(ant, con, weight=weight)

    return G


def compute_pca_3d(data: np.ndarray) -> np.ndarray:
    """Compute 3D PCA coordinates for the given data.

    Parameters
    ----------
    data : np.ndarray
        Data matrix of shape (n_samples, n_features).

    Returns
    -------
    np.ndarray
        3D projection of shape (n_samples, 3).
    """
    data_centered = data - np.mean(data, axis=0)
    _, _, Vt = np.linalg.svd(data_centered, full_matrices=False)
    return np.dot(data_centered, Vt[:3].T)


def visualize_latent_space(
    model: Any,
    labels: bool = True,
    n_items: int | None = None,
) -> Any:
    """Visualizes the item latent space in 3D using PCA.

    Parameters
    ----------
    model : ImplicitRecommender
        A fitted model with `item_factors`.
    labels : bool, default=True
        Whether to show item labels on hover.
    n_items : int, optional
        Limit visualization to the first N items (useful for very large models).

    Returns
    -------
    plotly.graph_objects.Figure
        A Plotly figure object.
    """
    try:
        import plotly.express as px
    except ImportError as err:
        raise ImportError(
            "The 'plotly' library is required to use `visualize_latent_space()`. "
            "Install it via `pip install plotly` or `uv add plotly`."
        ) from err

    factors = model.item_factors
    if n_items is not None:
        factors = factors[:n_items]

    # Normalize factors for better visualization (cosine space)
    norms = np.linalg.norm(factors, axis=1, keepdims=True)
    factors_norm = factors / np.clip(norms, a_min=1e-10, a_max=None)

    pca_coords = compute_pca_3d(factors_norm)

    df_viz = pd.DataFrame(
        {
            "x": pca_coords[:, 0],
            "y": pca_coords[:, 1],
            "z": pca_coords[:, 2],
        }
    )

    if labels and hasattr(model, "_item_labels") and model._item_labels is not None:
        item_labels = model._item_labels
        if n_items is not None:
            item_labels = item_labels[:n_items]
        df_viz["item"] = item_labels
        hover_data = ["item"]
    else:
        hover_data = None

    fig = px.scatter_3d(
        df_viz,
        x="x",
        y="y",
        z="z",
        hover_data=hover_data,
        template="plotly_dark",
        title="Item Latent Space (3D PCA)",
    )

    # Tight layout and smaller markers for a premium look
    fig.update_traces(marker={"size": 3, "opacity": 0.8})
    fig.update_layout(
        margin={"l": 0, "r": 0, "b": 0, "t": 30},
        scene={
            "xaxis": {"showticklabels": False, "title": ""},
            "yaxis": {"showticklabels": False, "title": ""},
            "zaxis": {"showticklabels": False, "title": ""},
        },
    )

    return fig
